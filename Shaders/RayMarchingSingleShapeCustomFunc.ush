#include  "/Project/SDFsLibrary.ush"



//--------------------- common parameters --------------------
//
//pGeometryType
	// 0-sdSphere
	// 1-sdBox
	// 2-sdRoundBox
	// 3-sdTorus
	// 4-sdLink
	// 5-sdCappedCylinder
	// 6-sdCone
	// 7-sdCapsule
//pMaxSteps 
//pWorldPosition
//pObjectPosition
//pCameraPosition
//pDisThreshold
//pSceneDepth
//pCameraVector
//
//---------------------- geometry parameters ------------------
//0-sdSphere  pSphereRadius 
//1-sdBox  pBoxDimension
//2-sdRoundBox pBoxDimension, pRound
//3-sdTorus  pTorusDimension
//4-sdLink pLinkLength, pLinkRadius1, pLinkRadius2
//5-sdCappedCylinder pCylinderRadius, pCylinderLength
//6-sdCone pConeAngle,pConeLength
//7-sdCapsule pCapsuleDimension1, pCapsuleDimension2, pCapsuleScalar

SDFs sdfLibrary;
float4 col = 0;
float3 pos = pWorldPosition;
float3 normal = 0;



for (int i = 0; i < pMaxSteps; i++)
{
	if(pSceneDepth < length(pos - pCameraPosition)) 
	break;


	
	float dist = 0;
	if(pGeometryType == 0.0)
	{
		dist = sdfLibrary.sdSphere(pos - pObjectPosition, pSphereRadius);
	}
	else if(pGeometryType == 1.0)
	{
		dist = sdfLibrary.sdBox(pos - pObjectPosition, pBoxDimension);
	}
	else if(pGeometryType == 2.0)
	{
		dist = sdfLibrary.sdRoundBox(pos - pObjectPosition, pBoxDimension, pRound);
	}
	else if(pGeometryType == 3.0)
	{
		dist = sdfLibrary.sdTorus(pos - pObjectPosition, pTorusDimension);
	}
	else if(pGeometryType == 4.0)
	{
		dist = sdfLibrary.sdLink( pos - pObjectPosition,  pLinkLength,  pLinkRadius1,  pLinkRadius2 );
	}
	else if(pGeometryType == 5.0)
	{
		dist = sdfLibrary.sdCappedCylinder( pos - pObjectPosition, pCylinderRadius, pCylinderLength);
	}
	else if(pGeometryType == 6.0)
	{
		dist = sdfLibrary.sdCone( pos - pObjectPosition, pConeAngle, pConeLength);
	}
	else if(pGeometryType == 7.0)
	{
		dist = sdfLibrary.sdCapsule( pos - pObjectPosition,  pCapsuleDimension1,  pCapsuleDimension2,  pCapsuleScalar );
	}
	
    if(dist < pDisThreshold)
    {
        col = float4(1, 0,0,1);
		
		///todo add normal
		//normal = RM.Normal(pos, spherePos, boxPos, Smooth);
	
        break;
    }
    pos += pCameraVector * dist;//need
   
}

return float4(normal, col.a);